<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Improved Three.js Track and Car</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <div id="timer" style="position: absolute; top: 10px; left: 1120px; font-size: 55px; color: white;"></div>

    <script type="module">
        
        let scene, camera, renderer, car = new THREE.Object3D();
        import { OrbitControls } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/OrbitControls.js";
        import { GLTFLoader } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/loaders/GLTFLoader.js";
        import CannonDebugger from "https://cdn.jsdelivr.net/npm/cannon-es-debugger@1.0.0/+esm";
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm';

        let cannonDebugRenderer;
        let physicsWorld, physicsObjects = [];
        let carBody, planeBody;
        let vehicle;

        

        function initPhysics() {
            
            // Create physics world
            physicsWorld = new CANNON.World();
            physicsWorld.gravity.set(0, -9.8, 0); // Set gravity

            /* // Convert the car model to a physics object
            const carShape = new CANNON.Box(new CANNON.Vec3(35, 0.25, 70)); // Adjust dimensions as per your car's geometry
            carBody = new CANNON.Body({ mass: 100 });
            carBody.addShape(carShape);
            carBody.position.set(0, 5.25, 0); // Ensure that this position matches the visual representation
            physicsWorld.addBody(carBody);
            physicsObjects.push({ mesh: car, body: carBody }); */

             // Convert the car model to a physics object
             const carBody = new CANNON.Body({ 
                mass: 150,
                position: new CANNON.Vec3(0, 40, 0), // Set initial position of the car
                shape: new CANNON.Box(new CANNON.Vec3(1.0, 0.5, 2)) // Set shape of the car
            });


            
            vehicle = new CANNON.RigidVehicle({ chassisBody: carBody });

            

            
            physicsObjects.push({ mesh: car, body: carBody });


            // Add the wheels

            const mass = 1;
            const axisWidth = 5;
            const wheelShape = new CANNON.Sphere(0.5);
            const wheelMaterial = new CANNON.Material('wheel');
            wheelMaterial.friction = 10.8;
            const down = new CANNON.Vec3(0, -1, 0);

            const wheelBodie1 = new CANNON.Body({ mass: mass, material: wheelMaterial });
            wheelBodie1.addShape(wheelShape);
            wheelBodie1.angularDamping = 0.4;
            vehicle.addWheel({
                body: wheelBodie1,
                position: new CANNON.Vec3(-1.2, -0.2, axisWidth/2),
                axis: new CANNON.Vec3(1, 0, 0),
                direction: down
            });

            const wheelBodie2 = new CANNON.Body({ mass: mass, material: wheelMaterial });
            wheelBodie2.addShape(wheelShape);
            wheelBodie2.angularDamping = 0.4;
            vehicle.addWheel({
                body: wheelBodie2,
                position: new CANNON.Vec3(1.2, -0.2, axisWidth/2),
                axis: new CANNON.Vec3(1, 0, 0),
                direction: down
            });

            const wheelBodie3 = new CANNON.Body({ mass: mass, material: wheelMaterial });
            wheelBodie3.addShape(wheelShape);
            wheelBodie3.angularDamping = 0.4;
            vehicle.addWheel({
                body: wheelBodie3,
                position: new CANNON.Vec3(-1.2, -0.2, -axisWidth/2),
                axis: new CANNON.Vec3(1, 0, 0),
                direction: down
            });

            const wheelBodie4 = new CANNON.Body({ mass: mass, material: wheelMaterial });
            wheelBodie4.addShape(wheelShape);
            wheelBodie4.angularDamping = 0.4;
            vehicle.addWheel({
                body: wheelBodie4,
                position: new CANNON.Vec3(1.2, -0.2, -axisWidth/2),
                axis: new CANNON.Vec3(1, 0, 0),
                direction: down
            });

            

            vehicle.addToWorld(physicsWorld);

            

        

            // Add collision shape for the plane
            const planeShape = new CANNON.Box(new CANNON.Vec3(500, 0.01, 500)); // Adjust dimensions as per your plane's size
            const planeBody = new CANNON.Body({ mass: 0 }); // Set mass to 0 since the plane should be static
            planeBody.addShape(planeShape);
            planeBody.position.set(0, 0.01, 0); // Set position just below the plane
            //tilt the plane 20  degrees
            //planeBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 9);

            //add friction to the plane
            const planeMaterial = new CANNON.Material('plane');
            const wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, planeMaterial, {
                friction: 0.5,
                restitution: 0.3
            });

            physicsWorld.addContactMaterial(wheelGroundContactMaterial);

            physicsWorld.addBody(planeBody);

            // Define the number of trees you want
            var numberOfTrees = 5;

            // Loop to create and position each tree
            for (var i = 0; i < numberOfTrees; i++) {
                var tree = createTree(); // Create a tree using a function (explained below)
                
                // Position each tree differently
                tree.position.set(7, 1.5, -10 + i * 5);
                tree.scale.set(2, 2, 2, 2);
                scene.add(tree); // Add the tree to the scene
                // Create a tree collision shape
                const treeShape = new CANNON.Box(new CANNON.Vec3(1, 1, 1));
                const treeBody = new CANNON.Body({ mass: 0 });
                treeBody.addShape(treeShape);
                treeBody.position.set(7, 1.5, -10 + i * 5);
                physicsWorld.addBody(treeBody);
            }
            for (var i = 0; i < numberOfTrees; i++) {
                var tree = createTree(); // Create a tree using a function (explained below)
                
                // Position each tree differently
                tree.position.set(-7, 1.5, -10 + i * 5);
                tree.scale.set(2, 2, 2, 2);
                scene.add(tree); // Add the tree to the scene
                // Create a tree collision shape
                const treeShape = new CANNON.Box(new CANNON.Vec3(1, 1, 1));
                const treeBody = new CANNON.Body({ mass: 0 });
                treeBody.addShape(treeShape);
                treeBody.position.set(-7, 1.5, -10 + i * 5);
                physicsWorld.addBody(treeBody);

                
            }

            
            const minX = -0  + 5; // Min X position
            const maxX = 80  - 5; // Max X position
            const minZ = -80  + 5; // Min Z position
            const maxZ = 80  - 5; // Max Z position

            // Define the number of trees you want inside the road
            const numberOfTreesInsideRoad = 25;

            // Loop to create and position each tree inside the road
            for (let i = 0; i < numberOfTreesInsideRoad; i++) {
                const tree = createTree(); // Create a tree using the function from your code

                // Generate random positions for trees within the road bounds
                const randomX = THREE.MathUtils.randFloat(minX, maxX);
                const randomZ = THREE.MathUtils.randFloat(minZ, maxZ);

                tree.position.set(randomX, 1.5, randomZ);
                tree.scale.set(2, 2, 2);
                scene.add(tree); // Add the tree to the scene
                // Create a tree collision shape
                const treeShape = new CANNON.Box(new CANNON.Vec3(1, 1, 1));
                const treeBody = new CANNON.Body({ mass: 0 });
                treeBody.addShape(treeShape);
                treeBody.position.set(randomX, 1.5, randomZ);
                physicsWorld.addBody(treeBody);
            }


            // Function to create a single tree
            function createTree() {
                var geometry = new THREE.BoxGeometry(1, 1, 1);

                var leaveDarkMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                var leaveLightMaterial = new THREE.MeshLambertMaterial({ color: 0x226A00 });
                var stemMaterial = new THREE.MeshLambertMaterial({ color: 0x7D5A4F });

                var stem = new THREE.Mesh(geometry, stemMaterial);
                stem.position.set(0, 0, 0);
                stem.scale.set(0.3, 1.5, 0.3);
                stem.castShadow = true; // Enable shadow casting for the stem

                var squareLeave01 = new THREE.Mesh(geometry, leaveDarkMaterial);
                squareLeave01.position.set(0.5, 1.6, 0.5);
                squareLeave01.scale.set(0.8, 0.8, 0.8);
                squareLeave01.castShadow = true; // Enable shadow casting for the leaves

                var squareLeave02 = new THREE.Mesh(geometry, leaveDarkMaterial);
                squareLeave02.position.set(-0.4, 1.3, -0.4);
                squareLeave02.scale.set(0.7, 0.7, 0.7);
                squareLeave02.castShadow = true; // Enable shadow casting for the leaves

                var squareLeave03 = new THREE.Mesh(geometry, leaveLightMaterial);
                squareLeave03.position.set(0.4, 1.7, -0.5);
                squareLeave03.scale.set(0.7, 0.7, 0.7);
                squareLeave03.castShadow = true; // Enable shadow casting for the leaves

                var leaveDark = new THREE.Mesh(geometry, leaveLightMaterial);
                leaveDark.position.set(0, 1.2, 0);
                leaveDark.scale.set(1, 2, 1);
                leaveDark.castShadow = true; // Enable shadow casting for the leaves

                var leaveLight = new THREE.Mesh(geometry, leaveLightMaterial);
                leaveLight.position.set(0, 1.2, 0);
                leaveLight.scale.set(1.1, 0.5, 1.1);
                leaveLight.castShadow = true; // Enable shadow casting for the leaves

                const tree = new THREE.Group();
                tree.add(leaveDark);
                tree.add(leaveLight);
                tree.add(squareLeave01);
                tree.add(squareLeave02);
                tree.add(squareLeave03);
                tree.add(stem);

                tree.rotation.y = 0;
                tree.rotation.x = 0;
                
                
                return tree; // Return the tree object
            }

            



            // check for collisions
            // Instantiate CannonDebugger
            cannonDebugRenderer = new CannonDebugger(scene, physicsWorld);
            cannonDebugRenderer.debug = true;

            
        }

        
        
        function updatePhysics() {
            // Step the physics simulation
            physicsWorld.step(1 / 60);

            // Update the position and rotation of the Three.js objects based on the physics simulation
            physicsObjects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });

            const maxSteerVal = Math.PI / 8; // Maximum steering value
            const maxSpeed = 60; // Maximum speed in units per second

            if (movement.forward) {
                
                vehicle.setWheelForce(-maxSpeed, 0);
                vehicle.setWheelForce(-maxSpeed, 1);
            } else if (movement.backward) {
              
                vehicle.setWheelForce(maxSpeed, 0);
                vehicle.setWheelForce(maxSpeed, 1);
            } else {
                vehicle.setWheelForce(0, 0);
                vehicle.setWheelForce(0, 1);
            }

            if (movement.left) {
                vehicle.setSteeringValue(maxSteerVal, 0);
                vehicle.setSteeringValue(maxSteerVal, 1);
            } else if (movement.right) {
                vehicle.setSteeringValue(-maxSteerVal, 0);
                vehicle.setSteeringValue(-maxSteerVal, 1);
            } else {
                vehicle.setSteeringValue(0, 0);
                vehicle.setSteeringValue(0, 1);
            }

            if (car.position.z <= 3 && car.position.z >=2 && car.position.x >= -10 && car.position.x <=10 && !isTimerRunning && turn === 0) {
        startTimer();
            }

            if (car.position.z <= -3 && car.position.z >=-5 && car.position.x >= -10 && car.position.x <=10 && isTimerRunning) {
                isTimerRunning = false;
                turn++;
            }

        }






        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            const plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
            plane.receiveShadow = true; // Enable shadow receiving
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.01;
            scene.add(plane);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Set initial camera position
            camera.position.set(0, 10, 10); // Behind and above the car
            camera.lookAt(new THREE.Vector3(0, 0, 0)); // Look at the center of the scene

            // Create renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadow mapping
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableRotate = true; // Enable rotation
            controls.enableZoom = false; // Disable zoom
            controls.enablePan = false; // Disable panning
            controls.target.set(0, 0, 0); // Set the focus point of the controls
            controls.update(); // Update controls

            const loader = new GLTFLoader();
            loader.load('scene.gltf', function(gltf) {
                car.add(gltf.scene)
                car.scale.set(0.04, 0.04, 0.04);
                car.position.set(0, 0.25, 0);
                gltf.scene.rotation.y = -Math.PI/2;
                gltf.scene.position.set(-12, 0, 0);
                
                car.castShadow = true; // Enable shadow casting for the car
                const carShapeGeometry = new THREE.BoxGeometry(30, 4.5, 70);
                const carShapeWireframe = new THREE.LineSegments(new THREE.EdgesGeometry(carShapeGeometry), new THREE.LineBasicMaterial({ color: 0xff0000 }));
                car.add(carShapeWireframe); // Add wireframe to the car object
                scene.add(car);
                // Initialize physics
                initPhysics();
            }, undefined, function(error) {
                console.error(error);
            });
            

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(-100, 100, 200);
            directionalLight.castShadow = true; // Enable shadow casting
            directionalLight.shadow.mapSize.width = 8024; // Width of the shadow map
            directionalLight.shadow.mapSize.height = 8024; // Height of the shadow map
            // Adjust shadow camera frustum
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -200;  // Increase left value
            directionalLight.shadow.camera.right = 200;  // Increase right value
            directionalLight.shadow.camera.top = 200;    // Increase top value
            directionalLight.shadow.camera.bottom = -200; // Increase bottom value

            scene.add(directionalLight);
            
            const curvePoints = [
                0, 0, -0,
                0, 0, 80,
                80, 0, 80,
                80, 0, -80,
                0, 0, -80,
                0, 0, -0    
            ];

            const pts = [];
            for (let i = 0; i < curvePoints.length; i += 3) {
                pts.push(new THREE.Vector3(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]));
            }

            const ls = 1400; // length segments
            const ws = 5; // width segments 
            const lss = ls + 1;
            const wss = ws + 1;

            const curve = new THREE.CatmullRomCurve3(pts);
            const points = curve.getPoints(ls);
            const len = curve.getLength();
            const lenList = curve.getLengths(ls);

            const faceCount = ls * ws * 2;
            const vertexCount = lss * wss;

            const indices = new Uint32Array(faceCount * 3);
            const vertices = new Float32Array(vertexCount * 3);
            const uvs = new Float32Array(vertexCount * 2);

            const g = new THREE.BufferGeometry();
            g.setIndex(new THREE.BufferAttribute(indices, 1));
            g.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            g.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            let idxCount = 0;
            let a, b1, c1, c2;

            for (let j = 0; j < ls; j++) {
            for (let i = 0; i < ws; i++) {
                a = wss * j + i;
                b1 = wss * (j + 1) + i;
                c1 = wss * (j + 1) + 1 + i;
                c2 = wss * j + 1 + i;

                indices[idxCount] = a;
                indices[idxCount + 1] = b1;
                indices[idxCount + 2] = c1;

                indices[idxCount + 3] = a;
                indices[idxCount + 4] = c1;
                indices[idxCount + 5] = c2;

                g.addGroup(idxCount, 6, i);

                idxCount += 6;
            }
        }

        let uvIdxCount = 0;

        for (let j = 0; j < lss; j++) {
            for (let i = 0; i < wss; i++) {
                uvs[uvIdxCount] = lenList[j] / len;
                uvs[uvIdxCount + 1] = i / ws;

                uvIdxCount += 2;
            }
        }
        let x, y, z;
        let posIdx = 0; // position index

        let tangent;
        const normal = new THREE.Vector3();
        const binormal = new THREE.Vector3(0, 1, 0);

        const t = []; // tangents
        const n = []; // normals
        const b = []; // binormals

        for (let j = 0; j < lss; j++) {
            tangent = curve.getTangent(j / ls);
            t.push(tangent.clone());

            normal.crossVectors(tangent, binormal);
            normal.y = 0;
            normal.normalize();
            n.push(normal.clone());

            binormal.crossVectors(normal, tangent);
            b.push(binormal.clone());
        }

        const dw = [-4, -3.7, -0.06, 0.06, 3.7, 4];

        for (let j = 0; j < lss; j++) {
            for (let i = 0; i < wss; i++) {
                x = points[j].x + dw[i] * n[j].x;
                y = points[j].y; // Keep the y-coordinate unchanged
                z = points[j].z + dw[i] * n[j].z;

                vertices[posIdx] = x;
                vertices[posIdx + 1] = y;
                vertices[posIdx + 2] = z;

                posIdx += 3;
            }
        }
        const tex = new THREE.TextureLoader().load('CentralMarking.png');
        tex.wrapS = THREE.RepeatWrapping;
        tex.repeat.set(ls * 2);

        const material = [
            new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }),
        ];

        const roadMesh = new THREE.Mesh(g, material);
        /* roadMesh.position.set(1.7, 0, 0);
        roadMesh.rotation.y = -1; */
        scene.add(roadMesh);

            

            // Set initial camera position
            camera.position.set(0, 5, 10);

            // Render the scene
            render();

            // Add event listeners for car movement
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }

        let startTime = 0;       // Time when the car crosses the start point
        let elapsedTime = 0;     // Elapsed time since the car crossed the start point
        let isTimerRunning = false;  // Flag to check if the timer is running
        let turn = 0;

        function startTimer() {
            isTimerRunning = true;      // Set the timer flag to true
            startTime = Date.now();     // Get the current time in milliseconds
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Backspace') {
                resetTimer();
            }
        });
        function resetTimer() {
            startTime = Date.now();
            elapsedTime = 0;
            isTimerRunning = false;
            car.position.set(0, 0.25, 0);
            car.rotation.set(0, 0, 0);
            turn = 0;
        }



        function render() {
            requestAnimationFrame(render);
            //updateCarMovement(); // Update car movement 
            //updateCameraPosition(); // Update camera position
            // Update the elapsed time if the timer is running
            const distance = 15; // Adjust the distance as needed
            const angle = car.rotation.y; // Get the car's rotation angle
            const offsetX = Math.sin(angle) * distance;
            const offsetZ = Math.cos(angle) * distance;
            camera.position.x = car.position.x - offsetX;
            camera.position.z = car.position.z - offsetZ;
            camera.position.y = car.position.y + 8; // Adjust the height of the camera as needed
            camera.lookAt(car.position); // Look at the car


    // Set the camera position and look at the car
            if (isTimerRunning) {
                elapsedTime = Date.now() - startTime;
            }

            // Convert milliseconds to seconds
            const seconds = (elapsedTime / 1000).toFixed(2);

            // Update the timer element content
            document.getElementById('timer').textContent = `Elapsed Time: ${seconds} seconds`;

            renderer.render(scene, camera);
            // Call the update method on cannonDebugRenderer
            if (physicsWorld) {
                updatePhysics();
                cannonDebugRenderer.update();
                
            }
        }

        const movement = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        function onKeyDown(event) {
            switch (event.key) {
                case 'ArrowUp':
                    movement.backward = true;
                    break;
                case 'ArrowDown':
                    movement.forward = true;
                    break;
                case 'ArrowLeft':
                    movement.left = true;
                    break;
                case 'ArrowRight':
                    movement.right = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key) {
                case 'ArrowUp':
                    movement.backward = false;
                    break;
                case 'ArrowDown':
                    movement.forward = false;
                    break;
                case 'ArrowLeft':
                    movement.left = false;
                    break;
                case 'ArrowRight':
                    movement.right = false;
                    break;
            }
        }

        let rotationAngle = 0;

       
        /* function updateCameraPosition() {
            // Update camera position to follow the car
            const distance = 10;
            camera.position.x = car.position.x - Math.sin(car.rotation.y) * distance;
            camera.position.z = car.position.z - Math.cos(car.rotation.y) * distance;
            camera.lookAt(car.position); // Look at the car
        } */

        init();
    </script>
</body>
</html>
