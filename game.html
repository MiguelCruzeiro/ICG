<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Racing Car Game</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        html, body {
            overflow: hidden;
            margin: 0;
            width: 100%;
            height: 100%;
        }

        #timer, #laps {
            position: absolute;
            top: 10px;
            font-size: 55px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #camera-view {
            position: absolute;
            top: 120px;
            font-size: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #timer {
            right: 10px;
        }

        #laps {
            left: 10px;
        }

        #camera-view {
            left: 10px;
        }

        #loading-screen {
            position: absolute;
            z-index: 2;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            opacity: 1;
            transition: 1s opacity;
        }

        #loading-screen.fade-out {
            opacity: 0;
        }

        #loader {
            display: block;
            position: relative;
            left: 50%;
            top: 50%;
            width: 150px;
            height: 150px;
            margin: -75px 0 0 -75px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #9370DB;
            -webkit-animation: spin 2s linear infinite;
            animation: spin 2s linear infinite;
        }
        #loader:before {
            content: "";
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #BA55D3;
            -webkit-animation: spin 3s linear infinite;
            animation: spin 3s linear infinite;
        }
        #loader:after {
            content: "";
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            bottom: 15px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #FF00FF;
            -webkit-animation: spin 1.5s linear infinite;
            animation: spin 1.5s linear infinite;
        }
        @-webkit-keyframes spin {
            0%   {
                -webkit-transform: rotate(0deg);
                -ms-transform: rotate(0deg);
                transform: rotate(0deg);
            }
            100% {
                -webkit-transform: rotate(360deg);
                -ms-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }
        @keyframes spin {
            0%   {
                -webkit-transform: rotate(0deg);
                -ms-transform: rotate(0deg);
                transform: rotate(0deg);
            }
            100% {
                -webkit-transform: rotate(360deg);
                -ms-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <section id="loading-screen">

        <div id="loader"></div>
    
    </section>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <div id="timer"></div>
    <!-- a div with the number of laps -->
    <div id="laps"></div>

    <div id="camera-view">Change Camera: C</div>   

    <script type="module">
        
        let scene, camera, activeCamera, cameraFirstPerson, cameraThirdPerson, renderer, car = new THREE.Object3D();
        import { OrbitControls } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/OrbitControls.js";
        import { GLTFLoader } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/loaders/GLTFLoader.js";
        import CannonDebugger from "https://cdn.jsdelivr.net/npm/cannon-es-debugger@1.0.0/+esm";
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm';
        import Stats from 'https://cdnjs.cloudflare.com/ajax/libs/stats.js/17/Stats.js'

        let cannonDebugRenderer;
        let physicsWorld, physicsObjects = [];
        let carBody, planeBody;
        let vehicle;
        let seconds = 0;
        let barrier, barrier1, barrier2, barrier3, barrier4, barrier5, barrier6;
        let engineSound;

        /* const stats = new Stats()
        stats.showPanel(0) // 0: fps, 1: ms, 2: mb, 3+: custom
        document.body.appendChild(stats.dom) */


        function initPhysics() {
            
            // Create physics world
            physicsWorld = new CANNON.World();
            physicsWorld.gravity.set(0, -9.8, 0); // Set gravity

             // Convert the car model to a physics object
             const carBody = new CANNON.Body({ 
                mass: 150,
                position: new CANNON.Vec3(0, 3, 0), // Set initial position of the car
                shape: new CANNON.Box(new CANNON.Vec3(1.0, 0.8, 2)) // Set shape of the car
            });


            
            vehicle = new CANNON.RigidVehicle({ chassisBody: carBody });

            

            
            physicsObjects.push({ mesh: car, body: carBody });


            // Add the wheels

            const mass = 1;
            const axisWidth = 5;
            const wheelShape = new CANNON.Sphere(0.5);
            const wheelMaterial = new CANNON.Material('wheel');
            wheelMaterial.friction = 10.8;
            const down = new CANNON.Vec3(0, -1, 0);
            

            const wheelBodie1 = new CANNON.Body({ mass: mass, material: wheelMaterial });
            wheelBodie1.addShape(wheelShape);
            wheelBodie1.angularDamping = 0.4;
            vehicle.addWheel({
                body: wheelBodie1,
                position: new CANNON.Vec3(-1.1, -0.5, axisWidth/2),
                axis: new CANNON.Vec3(1, 0, 0),
                direction: down
            });

            const wheelBodie2 = new CANNON.Body({ mass: mass, material: wheelMaterial });
            wheelBodie2.addShape(wheelShape);
            wheelBodie2.angularDamping = 0.4;
            vehicle.addWheel({
                body: wheelBodie2,
                position: new CANNON.Vec3(1.1, -0.5, axisWidth/2),
                axis: new CANNON.Vec3(1, 0, 0),
                direction: down
            });

            const wheelBodie3 = new CANNON.Body({ mass: mass, material: wheelMaterial });
            wheelBodie3.addShape(wheelShape);
            wheelBodie3.angularDamping = 0.4;
            vehicle.addWheel({
                body: wheelBodie3,
                position: new CANNON.Vec3(-1.1, -0.5, -axisWidth/2),
                axis: new CANNON.Vec3(1, 0, 0),
                direction: down
            });

            const wheelBodie4 = new CANNON.Body({ mass: mass, material: wheelMaterial });
            wheelBodie4.addShape(wheelShape);
            wheelBodie4.angularDamping = 0.4;
            vehicle.addWheel({
                body: wheelBodie4,
                position: new CANNON.Vec3(1.1, -0.5, -axisWidth/2),
                axis: new CANNON.Vec3(1, 0, 0),
                direction: down
            });



            vehicle.addToWorld(physicsWorld);

            

        

            // Add collision shape for the plane
            const planeShape = new CANNON.Box(new CANNON.Vec3(500, 0.01, 500)); // Adjust dimensions as per your plane's size
            const planeBody = new CANNON.Body({ mass: 0 }); // Set mass to 0 since the plane should be static
            planeBody.addShape(planeShape);
            planeBody.position.set(0, 0.01, 0); // Set position just below the plane
           
            const planeMaterial = new CANNON.Material('plane');
            const wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, planeMaterial, {
                friction: 0.5,
                restitution: 0.3
            });

            physicsWorld.addContactMaterial(wheelGroundContactMaterial);

            physicsWorld.addBody(planeBody);

            // Instantiate CannonDebugger
            cannonDebugRenderer = new CannonDebugger(scene, physicsWorld);
            cannonDebugRenderer.debug = true;

            const curvePoints = [
                -0, 0, 0,
                0, 0, 80,
                80, 0, 80,
                80, 0, -80,
                0, 0, -80,
                0, 0, -0    
            ];

            const pts = [];
            for (let i = 0; i < curvePoints.length; i += 3) {
                pts.push(new THREE.Vector3(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]));
            }

            const ls = 1400; // length segments
            const ws = 5; // width segments 
            const lss = ls + 1;
            const wss = ws + 1;

            const curve = new THREE.CatmullRomCurve3(pts);
            const points = curve.getPoints(ls);
            const len = curve.getLength();
            const lenList = curve.getLengths(ls);

            const faceCount = ls * ws * 2;
            const vertexCount = lss * wss;

            const indices = new Uint32Array(faceCount * 3);
            const vertices = new Float32Array(vertexCount * 3);
            const uvs = new Float32Array(vertexCount * 2);

            const g = new THREE.BufferGeometry();
            g.setIndex(new THREE.BufferAttribute(indices, 1));
            g.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            g.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            let idxCount = 0;
            let a, b1, c1, c2;

            for (let j = 0; j < ls; j++) {
            for (let i = 0; i < ws; i++) {
                a = wss * j + i;
                b1 = wss * (j + 1) + i;
                c1 = wss * (j + 1) + 1 + i;
                c2 = wss * j + 1 + i;

                indices[idxCount] = a;
                indices[idxCount + 1] = b1;
                indices[idxCount + 2] = c1;

                indices[idxCount + 3] = a;
                indices[idxCount + 4] = c1;
                indices[idxCount + 5] = c2;

                g.addGroup(idxCount, 6, i);

                idxCount += 6;
            }
        }

        let uvIdxCount = 0;

        for (let j = 0; j < lss; j++) {
            for (let i = 0; i < wss; i++) {
                uvs[uvIdxCount] = lenList[j] / len;
                uvs[uvIdxCount + 1] = i / ws;

                uvIdxCount += 2;
            }
        }
        let x, y, z;
        let posIdx = 0; // position index

        let tangent;
        const normal = new THREE.Vector3();
        const binormal = new THREE.Vector3(0, 1, 0);

        const t = []; // tangents
        const n = []; // normals
        const b = []; // binormals

        for (let j = 0; j < lss; j++) {
            tangent = curve.getTangent(j / ls);
            t.push(tangent.clone());

            normal.crossVectors(tangent, binormal);
            normal.y = 0;
            normal.normalize();
            n.push(normal.clone());

            binormal.crossVectors(normal, tangent);
            b.push(binormal.clone());
        }

        const dw = [-4, -3.7, -0.06, 0.06, 3.7, 4];

        for (let j = 0; j < lss; j++) {
            for (let i = 0; i < wss; i++) {
                x = points[j].x + dw[i] * n[j].x;
                y = points[j].y; // Keep the y-coordinate unchanged
                z = points[j].z + dw[i] * n[j].z;

                vertices[posIdx] = x;
                vertices[posIdx + 1] = y;
                vertices[posIdx + 2] = z;

                posIdx += 3;
            }
        }
        const tex = new THREE.TextureLoader().load('models/CentralMarking.png');
        tex.wrapS = THREE.RepeatWrapping;
        tex.repeat.set(ls * 2);

        const material = [
            new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }),
        ];

        const roadMesh = new THREE.Mesh(g, material);
        scene.add(roadMesh);

            // Define barrier properties
            const barrierHeight = 0.8; // Height of the barrier
            const barrierWidth = 1.0; // Width of the barrier
            const barrierDepth = 1.0; // Depth of the barrier
            const numBarriers = 300; // Number of barriers

            // Function to create barrier geometry
            function createBarrierGeometry() {
                return new THREE.BoxGeometry(barrierWidth, barrierHeight, barrierDepth);
            }

            // Calculate the interval to place the barriers
            const interval = Math.floor((points.length + 30) / (numBarriers - 30)); // Adjust as needed

            // Create barriers alongside the road
            for (let i = 1; i <= numBarriers; i++) {
                // Calculate the index of the point on the road's path
                const index = i * interval;
                
                // Get the point at this index
                const point = points[index];
                
                // Get the normal vector at this point
                const normal = n[index];

                // const for brown color
                const brown = 0x8B4513;
                
                const darkGrey = 0x696969;

                const leftBarrier = new THREE.Mesh(createBarrierGeometry(), new THREE.MeshPhongMaterial({ color: darkGrey }));
                leftBarrier.castShadow = true;
                const leftBarrierPosition = point.clone().add(normal.clone().multiplyScalar(-5.5)); // Adjust 5 based on barrier position
                leftBarrier.position.set(leftBarrierPosition.x, barrierHeight / 2, leftBarrierPosition.z);
                scene.add(leftBarrier);

                // Create right barrier
                const rightBarrier = new THREE.Mesh(createBarrierGeometry(), new THREE.MeshPhongMaterial({ color: darkGrey }));
                rightBarrier.castShadow = true;
                const rightBarrierPosition = point.clone().add(normal.clone().multiplyScalar(5.5)); // Adjust 5 based on barrier position
                rightBarrier.position.set(rightBarrierPosition.x, barrierHeight / 2, rightBarrierPosition.z);
                scene.add(rightBarrier);

                // Create physics body for left barrier
                const leftBarrierShape = new CANNON.Box(new CANNON.Vec3(barrierWidth / 2, barrierHeight, barrierDepth / 2));
                const leftBarrierBody = new CANNON.Body({ mass: 0 }); // Set mass to 0 since the barrier should be static
                leftBarrierBody.addShape(leftBarrierShape);
                leftBarrierBody.position.copy(leftBarrierPosition);
                physicsWorld.addBody(leftBarrierBody);

                // Create physics body for right barrier
                const rightBarrierShape = new CANNON.Box(new CANNON.Vec3(barrierWidth / 2, barrierHeight, barrierDepth / 2));
                const rightBarrierBody = new CANNON.Body({ mass: 0 }); // Set mass to 0 since the barrier should be static
                rightBarrierBody.addShape(rightBarrierShape);
                rightBarrierBody.position.copy(rightBarrierPosition);
                physicsWorld.addBody(rightBarrierBody);
            }
            
        }

        
        
        
        function updatePhysics() {
            // Step the physics simulation
            physicsWorld.step(1 / 60);

            // Update the position and rotation of the Three.js objects based on the physics simulation
            physicsObjects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });

            const maxSteerVal = Math.PI / 5; // Maximum steering value
            const maxSpeed = 85; // Maximum speed in units per second

            if (movement.forward) {
                
                vehicle.setWheelForce(-maxSpeed, 2);
                vehicle.setWheelForce(-maxSpeed, 3);
            } else if (movement.backward) {
              
                vehicle.setWheelForce(maxSpeed, 0);
                vehicle.setWheelForce(maxSpeed, 1);
            } else {
                vehicle.setWheelForce(0, 0);
                vehicle.setWheelForce(0, 1);
                vehicle.setWheelForce(0, 2);
                vehicle.setWheelForce(0, 3);


            }

            if (movement.left) {
                vehicle.setSteeringValue(maxSteerVal, 0);
                vehicle.setSteeringValue(maxSteerVal, 1);
            } else if (movement.right) {
                vehicle.setSteeringValue(-maxSteerVal, 0);
                vehicle.setSteeringValue(-maxSteerVal, 1);
            } else {
                vehicle.setSteeringValue(0, 0);
                vehicle.setSteeringValue(0, 1);
            }

            if (car.position.z <= 3 && car.position.z >=2 && car.position.x >= -10 && car.position.x <=10 && !isTimerRunning && turn === 1) {
        startTimer();
            }

            if (car.position.z <= -3 && car.position.z >=-3.3 && car.position.x >= 85 && car.position.x <=105 && isTimerRunning && turn === 1) {
                //isTimerRunning = false;
                //turn++;
                createbarriers();
            }

            if (car.position.z <= -3 && car.position.z >=-3.3 && car.position.x >= -10 && car.position.x <=10 && isTimerRunning && turn === 1) {
                //isTimerRunning = false;
                turn++;
            }
            if (car.position.z <= -3.5 && car.position.z >=-4 && car.position.x >= -10 && car.position.x <=10 && isTimerRunning && turn === 2) {
                isTimerRunning = false;
                turn = 2;
                // Redirect to the end page with the elapsed time as a query parameter
                saveScore(seconds);
                window.location.href = `end.html?time=${seconds}`;

            }

        }

        function createbarriers() {
            scene.add(barrier);
            const barrierShape = new CANNON.Box(new CANNON.Vec3(1.5, 0.8, 1.0));
            const barrierBody = new CANNON.Body({ mass: 0 });
            barrierBody.addShape(barrierShape);
            barrierBody.position.set(-2.2, 2.1, 11);
            physicsWorld.addBody(barrierBody);
            scene.add(barrier2);
            const barrierShape2 = new CANNON.Box(new CANNON.Vec3(1.5, 0.8, 1.0));   
            const barrierBody2 = new CANNON.Body({ mass: 0 });
            barrierBody2.addShape(barrierShape2);
            barrierBody2.position.set(36.5, 2.1, 93);
            barrierBody2.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI/2);
            physicsWorld.addBody(barrierBody2);
            scene.add(barrier3);
            const barrierShape3 = new CANNON.Box(new CANNON.Vec3(1.5, 0.8, 1.0));
            const barrierBody3 = new CANNON.Body({ mass: 0 });
            barrierBody3.addShape(barrierShape3);
            barrierBody3.position.set(-0.4, 2.1, 29);
            physicsWorld.addBody(barrierBody3);
            scene.add(barrier4);
            const barrierShape4 = new CANNON.Box(new CANNON.Vec3(1.5, 0.8, 1.0));
            const barrierBody4 = new CANNON.Body({ mass: 0 });
            barrierBody4.addShape(barrierShape4);
            barrierBody4.position.set(94.5, 2.1, 11.2);
            physicsWorld.addBody(barrierBody4);
            scene.add(barrier5);
            const barrierShape5 = new CANNON.Box(new CANNON.Vec3(1.5, 0.8, 1.0));
            const barrierBody5 = new CANNON.Body({ mass: 0 });
            barrierBody5.addShape(barrierShape5);
            barrierBody5.position.set(46.5, 2.1, -92.8);
            barrierBody5.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI/2);
            physicsWorld.addBody(barrierBody5);

        }
            

        function saveScore(time) {
            // Retrieve existing scores from local storage or initialize an empty array
            let scores = JSON.parse(localStorage.getItem('racingScores')) || [];

            // Add the new score
            scores.push(time);

            // Sort the scores in ascending order
            scores.sort((a, b) => a - b);

            // Keep only the top 10 scores
            scores = scores.slice(0, 10);

            // Save the updated scores back to local storage
            localStorage.setItem('racingScores', JSON.stringify(scores));
        }


        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            const plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
            plane.receiveShadow = true; // Enable shadow receiving
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.01;
            scene.add(plane);

            

            const loadingManager = new THREE.LoadingManager( () => {
                const loadingScreen = document.getElementById( 'loading-screen' );
                loadingScreen.classList.add( 'fade-out' );
            } );

            //add a texture to the plane
            const texture = new THREE.TextureLoader( loadingManager ).load('models/stone1.jpeg');
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(100, 100);
            plane.material.map = texture;


            // Create camera
            cameraThirdPerson = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraThirdPerson.position.set(0, 10, 10);
            cameraThirdPerson.lookAt(new THREE.Vector3(0, 0, 0));

            cameraFirstPerson = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cameraFirstPerson.position.set(0, 2, 5); // Closer to the car's front

            activeCamera = cameraThirdPerson; // Start with the third-person camera


            const listener = new THREE.AudioListener();
            cameraThirdPerson.add(listener);  // Assuming you have a camera in your scene

            engineSound = new THREE.Audio(listener);

            const audioLoader = new THREE.AudioLoader();
            audioLoader.load('models/audio.mp3', function(buffer) {
                engineSound.setBuffer(buffer);
                engineSound.setLoop(true);
                engineSound.setVolume(0.005);
                engineSound.play();
            });




            // Create renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadow mapping
            document.body.appendChild(renderer.domElement);

            const distance = 15; // Adjust the distance as needed
            const controls = new OrbitControls(cameraThirdPerson, renderer.domElement);
            controls.enableRotate = true; // Allow rotation
            controls.enableZoom = true; // Enable zooming
            controls.enablePan = false; // Disable panning
            controls.maxPolarAngle = Math.PI / 2; // Restrict vertical movement
            controls.minDistance = 5; // Minimum distance from the car
            controls.maxDistance = 20; // Maximum distance from the car

            const fogColor = new THREE.Color(0x87CEEB); // Same as the background color
            const fogNear = 8; // Adjust as needed
            const fogFar = 200; // Adjust as needed
            const fogDensity = 0.02; // Adjust as needed
            scene.fog = new THREE.Fog(fogColor, fogNear, fogFar);

            const loader = new GLTFLoader( loadingManager );
            loader.load('models/car/scene.gltf', function(gltf) {
                car.add(gltf.scene)
                car.scale.set(0.045, 0.045, 0.045);
                car.position.set(0, 0.20, 0);
                gltf.scene.rotation.y = -Math.PI/2;
                gltf.scene.position.set(-12, -20, 8);
                car.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true; // Enable shadow casting for the mesh
                        child.receiveShadow = true; // Enable shadow receiving for the mesh
                    }
                });
                
                
                scene.add(car);
                // Initialize physics
                
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/finish/scene.gltf', function(gltf) {
                const finish = gltf.scene;
                finish.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                finish.scale.set(11.5, 11.5, 11.5);
                finish.position.set(0, 0, 0);
                scene.add(finish);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/8x9_one_storey_house_design/scene.gltf', function(gltf) {
                const house = gltf.scene;
                house.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff }); // or MeshStandardMaterial
                        }
                        child.castShadow = true; // Enable shadow casting for the mesh
                        child.receiveShadow = true; // Enable shadow receiving for the mesh
                    }
                });
                house.scale.set(0.022, 0.022, 0.022);
                house.position.set(-30, 0, 10);
                scene.add(house);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/farm_house/scene.gltf', function(gltf) {
                const farmHouse = gltf.scene;
                farmHouse.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                farmHouse.scale.set(0.2, 0.2, 0.2);
                farmHouse.position.set(-23, 7, 40);
                scene.add(farmHouse);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/administration/scene.gltf', function(gltf) {
                const administration = gltf.scene;
                gltf.scene.rotation.y = -Math.PI/2;
                administration.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                administration.scale.set(1, 1, 1);
                administration.position.set(34, 0, 44);
                scene.add(administration);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/ussr_house/scene.gltf', function(gltf) {
                const ussrHouse = gltf.scene;
                ussrHouse.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                ussrHouse.scale.set(1.2, 1.2, 1.2);
                ussrHouse.position.set(114, 2.4, 10);
                scene.add(ussrHouse);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/house_aparment_russia/scene.gltf', function(gltf) {
                const houseApartmentRussia = gltf.scene;
                houseApartmentRussia.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                houseApartmentRussia.scale.set(0.8, 0.8, 0.8);
                houseApartmentRussia.position.set(54, 0, -100);
                scene.add(houseApartmentRussia);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/shopping_mall/scene.gltf', function(gltf) {
                const shoppingMall = gltf.scene;
                shoppingMall.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                shoppingMall.scale.set(1.2, 1.2, 1.2);
                shoppingMall.position.set(-64, 0, -25);
                scene.add(shoppingMall);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/school_building/scene.gltf', function(gltf) {
                const schoolBuilding = gltf.scene;
               
                schoolBuilding.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                schoolBuilding.scale.set(32.2, 32.2, 32.2);
                schoolBuilding.position.set(164, 0, -70);
                scene.add(schoolBuilding);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/city_park/scene.gltf', function(gltf) {
                const cityPark = gltf.scene;
                cityPark.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                cityPark.scale.set(1.2, 1.2, 1.2);
                cityPark.position.set(50, 0, -20);
                scene.add(cityPark);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/road_barrier/scene.gltf', function(gltf) {
                barrier = gltf.scene;
                barrier.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                barrier.scale.set(1.0, 1.0, 1.0);
                barrier.position.set(-1.5, 0, 10);
                barrier2 = barrier.clone();
                barrier2.position.set(35.5, 0, 92);
                //rotate the barrier 90 degrees
                barrier2.rotation.y = Math.PI/2;
                barrier3 = barrier.clone();
                barrier3.position.set(-1.5, 0, 30);
                barrier3.rotation.y = Math.PI;
                barrier4 = barrier.clone();
                barrier4.position.set(95.5, 0, 10);
                barrier5 = barrier.clone();
                barrier5.position.set(45.5, 0, -93.8);
                barrier5.rotation.y = Math.PI/2;
                
                
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/middle-size_tree/scene.gltf', function(gltf) {
                const middleSizeTree = gltf.scene;
                middleSizeTree.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                middleSizeTree.scale.set(5.1, 5.1, 5.1);
                middleSizeTree.position.set(10, 5, 35);
                scene.add(middleSizeTree);
                const clonedMiddleSizeTree = middleSizeTree.clone();
                clonedMiddleSizeTree.position.set(30, 5, -105);
                scene.add(clonedMiddleSizeTree);
                const clonedMiddleSizeTree2 = middleSizeTree.clone();
                clonedMiddleSizeTree2.position.set(100, 5, -85);
                scene.add(clonedMiddleSizeTree2);

            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/simple_tree/scene.gltf', function(gltf) {
                const simpleTree = gltf.scene;
                simpleTree.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                simpleTree.scale.set(0.6, 0.6, 0.6);
                simpleTree.position.set(0, 0, 105);
                scene.add(simpleTree);
                const clonedSimpleTree = simpleTree.clone();
                clonedSimpleTree.position.set(80, 0, -105);
                scene.add(clonedSimpleTree);

            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/house1/scene.gltf', function(gltf) {
                const house1 = gltf.scene;
                house1.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                house1.scale.set(1.7, 1.7, 1.7);
                house1.position.set(90, -1, 100);
                scene.add(house1);
            }, undefined, function(error) {
                console.error(error);
            });

            loader.load('models/countryside_house/scene.gltf', function(gltf) {
                const countrysideHouse = gltf.scene;
                gltf.scene.rotation.y = Math.PI/2;
                countrysideHouse.traverse(function(child) {
                    if (child.isMesh) {
                        if (child.material instanceof THREE.MeshBasicMaterial) {
                            child.material = new THREE.MeshPhongMaterial({ color: 0xffffff });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                countrysideHouse.scale.set(1.2, 1.2, 1.2);
                countrysideHouse.position.set(0, 0, -104);
                scene.add(countrysideHouse);
            }, undefined, function(error) {
                console.error(error);
            });


            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(-100, 100, 200);
            directionalLight.castShadow = true; // Enable shadow casting
            directionalLight.shadow.mapSize.width = 8024; // Width of the shadow map
            directionalLight.shadow.mapSize.height = 8024; // Height of the shadow map
            // Adjust shadow camera frustum
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -200;  // Increase left value
            directionalLight.shadow.camera.right = 200;  // Increase right value
            directionalLight.shadow.camera.top = 200;    // Increase top value
            directionalLight.shadow.camera.bottom = -200; // Increase bottom value

            scene.add(directionalLight);

            // Set initial camera position
            cameraThirdPerson.position.set(0, 5, 10);

            // Render the scene
            render();

            // Add event listeners for car movement
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
        }

        let startTime = 0;       // Time when the car crosses the start point
        let elapsedTime = 0;     // Elapsed time since the car crossed the start point
        let isTimerRunning = false;  // Flag to check if the timer is running
        let turn = 1;

        function startTimer() {
            isTimerRunning = true;      // Set the timer flag to true
            startTime = Date.now();     // Get the current time in milliseconds
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Backspace') {
                //resetTimer();
            }
        });
        function resetTimer() {
            startTime = Date.now();
            elapsedTime = 0;
            isTimerRunning = false;
            turn = 1;
            // put vehicle back to start position
            //stop the car
            vehicle.setWheelForce(0, 0);
            vehicle.setWheelForce(0, 1);
            vehicle.setSteeringValue(0, 0);
            vehicle.setSteeringValue(0, 1);
            vehicle.chassisBody.velocity.set(0, 0, 0);
            vehicle.chassisBody.angularVelocity.set(0, 0, 0);
            vehicle.chassisBody.position.set(0, 1.05, 0);
            vehicle.chassisBody.quaternion.set(0, 0, 0, 1);

            const quaternion = new CANNON.Quaternion();
            quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), 0); // Adjust the angle as needed
            vehicle.chassisBody.quaternion = quaternion;


        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'c' || event.key === 'C') {
                if (activeCamera === cameraThirdPerson) {
                    activeCamera = cameraFirstPerson;
                } else {
                    activeCamera = cameraThirdPerson;
                }
            }
        });




        function render() {
            requestAnimationFrame(render);
            //stats.begin();
            updateCameraPosition();

            if (isTimerRunning) {
                elapsedTime = Date.now() - startTime;
            }

            // Convert milliseconds to seconds
            seconds = (elapsedTime / 1000).toFixed(2);

            // Update the timer element content
            document.getElementById('timer').textContent = `Time: ${seconds}s`;
            document.getElementById('laps').textContent = `Lap: ${turn}/2`;

            renderer.render(scene, activeCamera);
            // Call the update method on cannonDebugRenderer
            if (physicsWorld) {
                updatePhysics();
                //cannonDebugRenderer.update();
                
            }
            //stats.end();
        }

        const movement = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        function onKeyDown(event) {
            switch (event.key) {
                case 'w':
                    movement.backward = true;
                    break;
                case 's':
                    movement.forward = true;
                    break;
                case 'a':
                    movement.left = true;
                    break;
                case 'd':
                    movement.right = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.key) {
                case 'w':
                    movement.backward = false;
                    break;
                case 's':
                    movement.forward = false;
                    break;
                case 'a':
                    movement.left = false;
                    break;
                case 'd':
                    movement.right = false;
                    break;
            }
        }

        let rotationAngle = 0;

       
        function updateCameraPosition() {
    if (activeCamera === cameraThirdPerson) {
        const q = new THREE.Quaternion();
        const cameraOffset = new THREE.Vector3(0, 5, -10);
        cameraOffset.applyQuaternion(car.getWorldQuaternion(q));
        cameraOffset.add(car.position);

        const cameraLookAt = new THREE.Vector3(0, 0, 0);
        cameraLookAt.applyQuaternion(car.getWorldQuaternion(q));
        cameraLookAt.add(car.position);

        const step = 0.05;
        activeCamera.position.lerp(cameraOffset, step);
        activeCamera.lookAt(cameraLookAt);
    } else if (activeCamera === cameraFirstPerson) {
        // First-person camera
        const q = new THREE.Quaternion();
        
        // Directly use car's world quaternion for the camera's rotation
        car.getWorldQuaternion(q);
        
        // Position the camera in front of the car
        const cameraOffset = new THREE.Vector3(0, 0.5, 1);
        cameraOffset.applyQuaternion(q);
        cameraOffset.add(car.position);

        const cameraLookAt = new THREE.Vector3(0.2, 0.5, 4);
        cameraLookAt.applyQuaternion(car.getWorldQuaternion(q));
        cameraLookAt.add(car.position);
        
        // Position and orientation of the camera
        activeCamera.position.copy(cameraOffset);
        activeCamera.quaternion.copy(q);
        activeCamera.lookAt(cameraLookAt);
    }


}


        
        init();
        initPhysics();
    </script>
</body>
</html>
